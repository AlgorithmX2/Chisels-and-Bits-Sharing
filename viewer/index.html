<html lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<title>Chisels &amp; Bits Model Viewer</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
<link href="https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css"/>
<style type="text/css">
	
	html,body { margin:0px; font-family: 'Open Sans', sans-serif; }
	p { margin: 30px; }
	
	#imageurl { position:absolute; color:white; right:25px; bottom:25px; border-radius:15px; padding:10px; background:rgba(124,124,124,0.25); }
	#imageurl a:active, 
	#imageurl a:visited, 
	#imageurl a:hover, 
	#imageurl a:link { color:white; }
	
	.l1 { text-align:c`enter; font-size:14px; }
	.l2 { text-align:center; font-size:11px; }
	
</style>

</head>
<body>

<script src="js/jquery.js"></script>
<script src="js/three.js"></script>
<script src="js/trackballcontrols.js"></script>
<script src="js/detector.js"></script>
<script src="js/base64.js"></script>
<script src="js/zlib.js"></script>
<script src="js/gzip.js"></script>
<script src="js/png.js"></script>
<script src="js/shareformatreader.js"></script>

<div id="imageurl"></div>

<script>

var container;

var camera, scene, renderer;

var mouseX = 0, mouseY = 0;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;
var jsonModel = {};

var tests = window.location.hash ? [ window.location.hash.substr(1) ] : [ 'mOsVNpm.png', 'laqg9n2.png', 'Lf7rjQf.png', 'cIsq4Js.png' ];
var randomModel = tests[Math.floor(Math.random()*tests.length)];

var imageurl = '';

function Utf8ArrayToStr(array) {
    var out, i, len, c;
    var char2, char3;

    out = "";
    len = array.length;
    i = 0;
    while(i < len) {
    c = array[i++];
    switch(c >> 4)
    { 
      case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
        // 0xxxxxxx
        out += String.fromCharCode(c);
        break;
      case 12: case 13:
        // 110x xxxx   10xx xxxx
        char2 = array[i++];
        out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
        break;
      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = array[i++];
        char3 = array[i++];
        out += String.fromCharCode(((c & 0x0F) << 12) |
                       ((char2 & 0x3F) << 6) |
                       ((char3 & 0x3F) << 0));
        break;
    }
    }

    return out;
}

function readByte( readerState )
{
	// readerState: pixelbytes, index, c
	do
	{
		var currentValue = readerState[0][ readerState[1] + readerState[2] ];
		var alpha = readerState[0][ readerState[1] + 3 ];	
		
		readerState[2]++;
		
		if ( alpha > 128 )
		{
			var p1 = readerState[0][ readerState[1] + 0 ];
			var p2 = readerState[0][ readerState[1] + 1 ];
			var p3 = readerState[0][ readerState[1] + 2 ];
			
			currentValue = ( ( alpha & 3 ) << 6 ) | ( ( p1 & 3 ) << 4 ) | ( ( p2 & 3 ) << 2 ) | ( ( p3 & 3 ) );
			
			readerState[1] += 4;
			readerState[2] = 0;
		}
		else if ( readerState[2] >= 3 )
		{
			readerState[1] += 4;
			readerState[2] = 0;
		}
		
		break;
	}
	while ( true );
	
	return currentValue;
}

function imageDecode( pixelbytes )
{
	var readerState = [ pixelbytes, 0, 0 ];
	
	var size = readByte( readerState ) << 24;
	size |= readByte( readerState ) << 16;
	size |= readByte( readerState ) << 8;
	size |= readByte( readerState );
	
	var out = new Uint8Array(size);
	for ( var x = 0; x < size; ++x )
		out[x] = readByte( readerState );
	
	return out;
}

if ( randomModel.indexOf( 'http://' ) == -1 )
{
	if (location.protocol === 'https:') {
		randomModel = 'https://i.imgur.com/' + randomModel;
	} else {
		randomModel = 'http://i.imgur.com/' + randomModel;
	}
}

if ( Detector.webgl )
{
	PNG.load( randomModel + '.png', null, function( png ) {
		
		try
		{
			var gzipData = imageDecode( png.decodePixels() );
			imageurl = randomModel.replace( 'i.imgur.com', 'imgur.com' );
			imageurl = randomModel.replace( '.png', '' );
			$('#imageurl').html( '<div class="l1">WIP Chisels & Bits Viewer - <a href="about.html">Whats this?</a></div><div class="l2">View screenshot: <a target="_blank" href="' + imageurl + '">' + imageurl + '</a></div>');
		}
		catch( e )
		{
			console.log(e);
			document.body.innerHTML = '<p>Model was not validly encoded into image.</p>';
			return;
		}
		
		deflateAndLoad(gzipData);
		
	} );
}
else
{
	document.body.appendChild( Detector.getWebGLErrorMessage() );
}

function deflateAndLoad( gzipData )
{
	try
	{
		var binaryInflated = pako.inflate( gzipData );
		//var jsonData = Utf8ArrayToStr(binaryInflated);
	}
	catch( e )
	{
		console.log(e);
		document.body.innerHTML = '<p>Could not load model, format appears to be wrong.. <a href="./">View Tests?</a></p>';
		return;
	}

	try
	{
		var reader = new shareformatreader(binaryInflated);
		var jsonModel = reader.readModel();
		
		//jsonModel = JSON.parse( jsonData );
		if ( jsonModel == null || jsonModel == false ) throw {};
	}
	catch( e )
	{
		console.log(binaryInflated);
		console.log(e);
		document.body.innerHTML = '<p>Model was not valid.</p>';
		return;
	}
	
	try
	{
		init();
		
		addModel( jsonModel );
		animate();
	}
	catch( e ) 
	{
		console.log(e);
	}
}

function adjustGeometry( geometry )
{
	var c = new THREE.Vector3;
	
	c.addVectors(
		geometry.boundingBox.min,
		geometry.boundingBox.max
  );
  
  c.divideScalar(2);

	var l = geometry.vertices.length;
	for ( var x = 0; x < l; ++x )
	{
		var v = geometry.vertices[x];
		v.sub( c );
	}
	
	geometry.computeBoundingSphere();
	geometry.computeBoundingBox();
	
	return c;
}

function snagPos( data, index, size )
{
	var out = data.substr( index[0], size );
	index[0]+=size;
	
	return parseInt( out, 36 );
}

function readVertData( data, index, x,y,z )
{
	var out = [ 0, 0, 0, 0, 0 ]; // def

	out[0] = snagPos( data, index, x );
	out[1] = snagPos( data, index, y );
	out[2] = snagPos( data, index, z );
	out[3] = snagPos( data, index, 1 );	
	out[4] = snagPos( data, index, 1 );	
	
	return out;
}

var textureMaps = {};
var textureSource = {};
function addModel( jsonModel )
{
	textureSource = jsonModel.textures;
	
	var modelsByMaterial = {};
	var models = [];
	
	for ( var x = 0; x < jsonModel.model.length; x++ )
	{
		var face = jsonModel.model[x];
		var material = face.m;
		
		if ( ! modelsByMaterial[ material ] )
		{
			var list = [];
			list.textureName = jsonModel.materials[ material ][2];
			list.layer = jsonModel.materials[ material ][0];
			list.color = jsonModel.materials[ material ][1];
			models.push( list );
			modelsByMaterial[ material ] = list;
		}
		
		modelsByMaterial[ material ].push( face );
	}
	
	var transparentFaces = 0;
	var normalFaces = 0;
	
	var meshes = [];
	var sizeEnc = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	
	var transparentBlocks = {};
	var transparentBlockList = [];
	

	for ( var x = 0; x < models.length; x++ )
	{
		var model = models[x];
		
		for ( var l = 0; l < model.length; l++ )
		{
			var faceList = model[l].f;
			var translucent = model.layer == 't';
			var material = new THREE.MeshLambertMaterial( { alphaTest: model.layer == 'a' ? 0.5 : 0, transparent : translucent, map: getTexture( model.textureName ), color: model.color & 0xffffff } );
			
			transparentBlocks = {};
			transparentBlockList = [];
			
			var addLayer = false;
			var layerGeometry = new THREE.Geometry();
			layerGeometry.faceVertexUvs[0] = [];
			
			for ( var ll = 0; ll < faceList.length; ll++ )
			{
				var face = faceList[ll];
				
				var p1 = face[0];
				var p2 = face[1];
				var p3 = face[2];
				var p4 = face[3];
				
				var uvA = [];
				var uvB = [];

				var geometry = layerGeometry;
				
				if ( translucent )
				{
					var key = ( p1[0] / 16 ).toFixed(0) + '-' + ( p1[1] / 16 ).toFixed(0) + '-' + ( p1[2] / 16 ).toFixed(0);
					var faceGeometry = transparentBlocks[ key ];
					
					if ( ! faceGeometry )
					{
						var faceGeometry = new THREE.Geometry();
						faceGeometry.faceVertexUvs[0] = [];
						
						transparentBlocks[ key ] = faceGeometry;
						transparentBlockList.push( key );
					}
					
					geometry = faceGeometry;
					++transparentFaces;
				}
				else
				{
					++normalFaces;
					addLayer = true;
				}
				
				var index = geometry.vertices.length;
				
				geometry.vertices.push(
					asVert( p1[0], p1[1], p1[2] ),
					asVert( p2[0], p2[1], p2[2] ),
					asVert( p3[0], p3[1], p3[2] ),
					asVert( p4[0], p4[1], p4[2] )
				);
				
				uvA.push(
					asUV( p1[3], p1[4] ),
					asUV( p2[3], p2[4] ),
					asUV( p3[3], p3[4] )
				);
				
				uvB.push(
					asUV( p1[3], p1[4] ),
					asUV( p3[3], p3[4] ),
					asUV( p4[3], p4[4] )
				);
				
				geometry.faceVertexUvs[0].push( uvA );
				geometry.faceVertexUvs[0].push( uvB );
				
				geometry.faces.push( new THREE.Face3( index, index + 1, index + 2 ) );
				geometry.faces.push( new THREE.Face3( index, index + 2, index + 3 ) );
			}
			
			if ( addLayer )
			{
				layerGeometry.computeFaceNormals();
				layerGeometry.computeBoundingSphere();
				layerGeometry.computeBoundingBox();
				
				var adjustment = adjustGeometry( layerGeometry );
				var mesh = new THREE.Mesh( layerGeometry, material );
				mesh.adjustmentX = adjustment.x;
				mesh.adjustmentY = adjustment.y;
				mesh.adjustmentZ = adjustment.z;
				meshes.push( mesh );
			}
			
			for ( var j = 0; j < transparentBlockList.length; ++j )
			{
				var faceGeometry = transparentBlocks[ transparentBlockList[ j ] ];
				
				faceGeometry.computeFaceNormals();
				faceGeometry.computeBoundingSphere();
				faceGeometry.computeBoundingBox();
				
				var adjustment = adjustGeometry( faceGeometry );
				var mesh = new THREE.Mesh( faceGeometry, material );
				mesh.adjustmentX = adjustment.x;
				mesh.adjustmentY = adjustment.y;
				mesh.adjustmentZ = adjustment.z;
				meshes.push( mesh );
			}
			
		}
	}
	
	for ( var x = 0; x < meshes.length; ++x )
	{
		var mesh = meshes[x];		
		mesh.position.set( -(maxX - minX) / 2 + mesh.adjustmentX, -(maxY - minY) / 2 + mesh.adjustmentY, -(maxZ - minZ) / 2 + mesh.adjustmentZ );
		scene.add( mesh );
	}

	console.log( "transparentFaces: " + transparentFaces );
	console.log( "normalFaces: " + normalFaces );
}

function fromB36( arr )
{
	for ( var x = 0; x < arr.length; ++x )
	{
		arr[x] = parseInt( arr[x], 36 );
	}
	
	return arr;
}

var minX=1000, minY=1000, minZ=1000;
var maxX=-1000, maxY=-1000, maxZ=-1000;

function asVert( x, y, z )
{
	x /= 16;
	y /= 16;
	z /= 16;
	
	if ( minX > x ) minX = x;
	if ( maxX < x ) maxX = x;
	
	if ( minY > y ) minY = y;
	if ( maxY < y ) maxY = y;
	
	if ( minZ > z ) minZ = z;
	if ( maxZ < z ) maxZ = z;
	
	return new THREE.Vector3(x,y,z);
}

function asUV( u, v )
{
	return new THREE.Vector2(u/16,v/16);
}

function getTexture( id )
{
	if ( ! textureMaps[ id ] )
	{
		console.log( "Loading Texture: " + id );
		textureMaps[ id ] = loadTexture( textureSource[ id ] );
	}
	
	return textureMaps[ id ];
}

function loadTexture( png )
{
	var dataURL = 'data:image/png;base64,' + encode64( png );
	var image = document.createElement( 'img' );
	var texture = new THREE.Texture( image );
	image.onload = function()  { texture.needsUpdate = true; };
	image.src = dataURL;
	texture.magFilter = THREE.NearestFilter;
	texture.minFilter = THREE.NearestFilter;
	return texture;
}

var light1;

function init() {

	container = document.createElement( 'div' );
	document.body.appendChild( container );

	camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
	camera.position.z = 14;
	camera.position.y = 14;
	camera.position.x = 14;

	controls = new THREE.TrackballControls( camera );
	controls.rotateSpeed = 5.0;
	controls.zoomSpeed = 5;
	controls.panSpeed = 2;
	controls.noZoom = false;
	controls.noPan = false;
	controls.staticMoving = true;
	controls.dynamicDampingFactor = 0.3;
	
	scene = new THREE.Scene();
	var ambient = new THREE.AmbientLight( 0x303030 );
	scene.add( ambient );
	
	light1 = new THREE.PointLight( 0xffffff, 0.5, 5000 );
	scene.add( light1 );
	
	renderer = new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	container.appendChild( renderer.domElement );

	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	window.addEventListener( 'resize', onWindowResize, false );
}

function onWindowResize()
{

	windowHalfX = window.innerWidth / 2;
	windowHalfY = window.innerHeight / 2;

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

}

function onDocumentMouseMove( event )
{
	
	mouseX = ( event.clientX - windowHalfX ) / 2;
	mouseY = ( event.clientY - windowHalfY ) / 2;
	
}

function animate()
{
	
	requestAnimationFrame( animate );
	render();
	
}

function render()
{
	var up = new THREE.Vector3();
	up.copy( camera.up );
	
	var forward = new THREE.Vector3();
	forward.copy( camera.getWorldDirection() );
	forward.normalize();
	
	var left = new THREE.Vector3();
	left.crossVectors( up, forward );
	
	var lPos = [
		camera.position.x + up.x * 10 + left.x * 10,
		camera.position.y + up.y * 10 + left.y * 10,
		camera.position.z + up.z * 10 + left.z * 10
	];
	
	light1.position.set( lPos[0], lPos[1], lPos[2] );
	
	controls.update();
	//camera.lookAt( scene.position );
	renderer.render( scene, camera );
	
}

</script></body></html>